<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Postgres full-text search is Good Enough!</title>
  <link rel="shortcut icon" href="/assets/images/favicon.ico">
  <link rel="stylesheet" href="/assets/css/style.css">
  <link rel="alternate" type="application/rss+xml" title="My Blog" href="/rss.xml">
  <link rel="stylesheet" href="/assets/css/highlight.css">
</head>
<body>

  <nav class="main-nav">
    
        <a href='/'> <span class="arrow">‚Üê</span> Home </a>
    

    
        
            <a href='/about'>About </a>
        
    
        <a href='http://bit.ly/rachbelaid'>Twitter</a>
</nav>


  

  <section id="wrapper" class="">
    <article class="post">
    <header>
        <h1>Postgres full-text search is Good Enough!</h1>
        <h2 class="headline">July 13, 2015</h2>
    </header>
    <section id="post-body">
        <p>When you have to build a web application, you are often asked to add search. The magnifying glass is something that we now add to wireframes without even knowing what we are going to search.</p>

<p>The search has become an important feature and we&#39;ve seen a big increase in the popularity of tools like <a href="http://elasticsearch.org/">elasticsearch</a> and <a href="https://lucene.apache.org/solr/">SOLR</a> which are both based on <a href="https://lucene.apache.org/">lucene</a>. They are great tools but before going down the road of Weapons of Mass <del>Destruction</del> Search, maybe what you need is something a bit lighter which is simply <strong>good enough</strong>! </p>

<p>What do you I mean by &#39;good enough&#39;? I mean a search engine with the following features:</p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Stemming">Stemming</a></li>
<li>Ranking / Boost</li>
<li>Support Multiple languages</li>
<li>Fuzzy search for misspelling</li>
<li>Accent support </li>
</ul>

<p>Luckily PostgreSQL supports all these features.</p>

<p>This post is aimed at people who:</p>

<ul>
<li>use PostgreSQL and don&#39;t want to install an extra dependency for their search engine.</li>
<li>use an alternative database (eg: MySQL) and have the need for better full-text search features. </li>
</ul>

<p>In this post, we are going to progressively illustrate some of the full-text search features in Postgres based on the following tables and data:</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">author</span><span class="p">(</span>
   <span class="n">id</span> <span class="nb">SERIAL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
   <span class="n">name</span> <span class="nb">TEXT</span> <span class="k">NOT</span> <span class="k">NULL</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">post</span><span class="p">(</span>
   <span class="n">id</span> <span class="nb">SERIAL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
   <span class="n">title</span> <span class="nb">TEXT</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
   <span class="n">content</span> <span class="nb">TEXT</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
   <span class="n">author_id</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">references</span> <span class="n">author</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> 
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">tag</span><span class="p">(</span>
   <span class="n">id</span> <span class="nb">SERIAL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
   <span class="n">name</span> <span class="nb">TEXT</span> <span class="k">NOT</span> <span class="k">NULL</span> 
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">posts_tags</span><span class="p">(</span>
   <span class="n">post_id</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">references</span> <span class="n">post</span><span class="p">(</span><span class="n">id</span><span class="p">),</span>
   <span class="n">tag_id</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">references</span> <span class="n">tag</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
 <span class="p">);</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">author</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> 
<span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Pete Graham&#39;</span><span class="p">),</span> 
       <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;Rachid Belaid&#39;</span><span class="p">),</span> 
       <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;Robert Berry&#39;</span><span class="p">);</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">tag</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> 
<span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;scifi&#39;</span><span class="p">),</span> 
       <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;politics&#39;</span><span class="p">),</span> 
       <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;science&#39;</span><span class="p">);</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">post</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">content</span><span class="p">,</span> <span class="n">author_id</span><span class="p">)</span> 
<span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Endangered species&#39;</span><span class="p">,</span> 
        <span class="s1">&#39;Pandas are an endangered species&#39;</span><span class="p">,</span> <span class="mi">1</span> <span class="p">),</span> 
       <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;Freedom of Speech&#39;</span><span class="p">,</span> 
        <span class="s1">&#39;Freedom of speech is a necessary right&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> 
       <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;Star Wars vs Star Trek&#39;</span><span class="p">,</span> 
        <span class="s1">&#39;Few words from a big fan&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>


<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">posts_tags</span> <span class="p">(</span><span class="n">post_id</span><span class="p">,</span> <span class="n">tag_id</span><span class="p">)</span> 
<span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> 
       <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> 
       <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span></code></pre></div>

<p>It&#39;s a traditional blog-like application with <code>post</code> objects, which have a <code>title</code> and <code>content</code>. A <code>post</code> is associated to an <code>author</code> via a foreign key. A <code>post</code> itself can have multiple tags. </p>

<h3>What is Full-Text Search.</h3>

<p>First, let&#39;s look at the definition:</p>

<blockquote>
<p>In text retrieval, <strong>full-text search</strong> refers to techniques for searching a single computer-stored <strong>document</strong> or a collection in a full-text database. The full-text search is distinguished from searches based on metadata or on parts of the original texts represented in databases.</p>

<p>-- <a href="http://en.wikipedia.org/wiki/Full_text_search">Wikipedia</a></p>
</blockquote>

<p>This definition introduces the concept of a document, which is important. When you run a search across your data, you are looking into meaningful entities for which you want to search, these are your documents! The PostgreSQL documentation explains it amazingly.</p>

<blockquote>
<p>A document is the unit of searching in a full-text search system; for example, a magazine article or email message. </p>

<p>-- <site><a href="http://www.postgresql.org/docs/9.3/static/textsearch-intro.html#TEXTSEARCH-DOCUMENT">Postgres documentation</a></p>
</blockquote>

<p>This document can be across multiple tables and it represents a logical entity which we want to search for.</p>

<h3>Build our document</h3>

<p>In the previous section, we introduced the concept of document. A document is not related to our table schema but to data; together these represent a meaningful object.
Based on our example schema, the document is composed of:</p>

<ul>
<li><code>post.title</code></li>
<li><code>post.content</code></li>
<li><code>author.name</code> of the <code>post</code></li>
<li>all <code>tag.name</code> associated to the <code>post</code></li>
</ul>

<p>To create our document based on this criteria imagine this SQL query:</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="n">post</span><span class="p">.</span><span class="n">title</span> <span class="o">||</span> <span class="s1">&#39; &#39;</span> <span class="o">||</span> 
       <span class="n">post</span><span class="p">.</span><span class="n">content</span> <span class="o">||</span> <span class="s1">&#39; &#39;</span> <span class="o">||</span>
       <span class="n">author</span><span class="p">.</span><span class="n">name</span> <span class="o">||</span> <span class="s1">&#39; &#39;</span> <span class="o">||</span>
       <span class="n">coalesce</span><span class="p">((</span><span class="n">string_agg</span><span class="p">(</span><span class="n">tag</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)),</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">document</span>
<span class="k">FROM</span> <span class="n">post</span>
<span class="k">JOIN</span> <span class="n">author</span> <span class="k">ON</span> <span class="n">author</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">post</span><span class="p">.</span><span class="n">author_id</span>
<span class="k">JOIN</span> <span class="n">posts_tags</span> <span class="k">ON</span> <span class="n">posts_tags</span><span class="p">.</span><span class="n">post_id</span> <span class="o">=</span> <span class="n">posts_tags</span><span class="p">.</span><span class="n">tag_id</span>
<span class="k">JOIN</span> <span class="n">tag</span> <span class="k">ON</span> <span class="n">tag</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">posts_tags</span><span class="p">.</span><span class="n">tag_id</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">post</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">author</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>

              <span class="n">document</span>
<span class="c1">--------------------------------------------------</span>
<span class="n">Endangered</span> <span class="n">species</span> <span class="n">Pandas</span> <span class="k">are</span> <span class="n">an</span> <span class="n">endangered</span> <span class="n">species</span> <span class="n">Pete</span> <span class="n">Graham</span> <span class="n">politics</span>
<span class="n">Freedom</span> <span class="k">of</span> <span class="n">Speech</span> <span class="n">Freedom</span> <span class="k">of</span> <span class="n">speech</span> <span class="k">is</span> <span class="n">a</span> <span class="n">necessary</span> <span class="k">right</span> <span class="n">Rachid</span> <span class="n">Belaid</span> <span class="n">politics</span>
<span class="n">Star</span> <span class="n">Wars</span> <span class="n">vs</span> <span class="n">Star</span> <span class="n">Trek</span> <span class="n">Few</span> <span class="n">words</span> <span class="k">from</span> <span class="n">a</span> <span class="n">big</span> <span class="n">fan</span> <span class="n">Robert</span> <span class="n">Berry</span> <span class="n">politics</span>
<span class="mi">3</span> <span class="k">rows</span><span class="p">)</span></code></pre></div>

<p>As we are grouping by <code>post</code> and <code>author</code>, we are using <code>string_agg()</code> as the aggregate function because multiple <code>tag</code> can be associated to a <code>post</code>. Even if <code>author</code> is a foreign key and a <code>post</code> cannot have more than one <code>author</code>, it is required to add an aggregate function for <code>author</code> or to add <code>author</code> to the <code>GROUP BY</code>.</p>

<p>We also used <code>coalesce()</code>. When a value can be <code>NULL</code> then it&#39;s good practice to use the <code>coalesce()</code> function, otherwise the concatenation will result in a <code>NULL</code> value too.</p>

<p>At this stage, our document is simply a long <code>string</code> and this doesn&#39;t help us; we need to transform it into the right format via the function <code>to_tsvector()</code>.</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="n">to_tsvector</span><span class="p">(</span><span class="n">post</span><span class="p">.</span><span class="n">title</span><span class="p">)</span> <span class="o">||</span> 
       <span class="n">to_tsvector</span><span class="p">(</span><span class="n">post</span><span class="p">.</span><span class="n">content</span><span class="p">)</span> <span class="o">||</span>
       <span class="n">to_tsvector</span><span class="p">(</span><span class="n">author</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="o">||</span>
       <span class="n">to_tsvector</span><span class="p">(</span><span class="n">coalesce</span><span class="p">((</span><span class="n">string_agg</span><span class="p">(</span><span class="n">tag</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)),</span> <span class="s1">&#39;&#39;</span><span class="p">))</span> <span class="k">as</span> <span class="n">document</span>
<span class="k">FROM</span> <span class="n">post</span>
<span class="k">JOIN</span> <span class="n">author</span> <span class="k">ON</span> <span class="n">author</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">post</span><span class="p">.</span><span class="n">author_id</span>
<span class="k">JOIN</span> <span class="n">posts_tags</span> <span class="k">ON</span> <span class="n">posts_tags</span><span class="p">.</span><span class="n">post_id</span> <span class="o">=</span> <span class="n">posts_tags</span><span class="p">.</span><span class="n">tag_id</span>
<span class="k">JOIN</span> <span class="n">tag</span> <span class="k">ON</span> <span class="n">tag</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">posts_tags</span><span class="p">.</span><span class="n">tag_id</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">post</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">author</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
           
               <span class="n">document</span>
 <span class="c1">--------------------------------------------------</span>
 <span class="s1">&#39;endang&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span> <span class="s1">&#39;graham&#39;</span><span class="p">:</span><span class="mi">9</span> <span class="s1">&#39;panda&#39;</span><span class="p">:</span><span class="mi">3</span> <span class="s1">&#39;pete&#39;</span><span class="p">:</span><span class="mi">8</span> <span class="s1">&#39;polit&#39;</span><span class="p">:</span><span class="mi">10</span> <span class="s1">&#39;speci&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span>
 <span class="s1">&#39;belaid&#39;</span><span class="p">:</span><span class="mi">12</span> <span class="s1">&#39;freedom&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span>  <span class="s1">&#39;necessari&#39;</span><span class="p">:</span><span class="mi">9</span> <span class="s1">&#39;polit&#39;</span><span class="p">:</span><span class="mi">13</span> <span class="s1">&#39;rachid&#39;</span><span class="p">:</span><span class="mi">11</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span><span class="mi">10</span> <span class="s1">&#39;speech&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span>
 <span class="s1">&#39;berri&#39;</span><span class="p">:</span><span class="mi">13</span> <span class="s1">&#39;big&#39;</span><span class="p">:</span><span class="mi">10</span> <span class="s1">&#39;fan&#39;</span><span class="p">:</span><span class="mi">11</span> <span class="s1">&#39;polit&#39;</span><span class="p">:</span><span class="mi">14</span> <span class="s1">&#39;robert&#39;</span><span class="p">:</span><span class="mi">12</span> <span class="s1">&#39;star&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span> <span class="s1">&#39;trek&#39;</span><span class="p">:</span><span class="mi">5</span> <span class="s1">&#39;vs&#39;</span><span class="p">:</span><span class="mi">3</span> <span class="s1">&#39;war&#39;</span><span class="p">:</span><span class="mi">2</span> <span class="s1">&#39;word&#39;</span><span class="p">:</span><span class="mi">7</span>
<span class="p">(</span><span class="mi">3</span> <span class="k">rows</span><span class="p">)</span></code></pre></div>

<p>This query will return our document as <code>tsvector</code> which is a type suited to full-text search. Let&#39;s try to convert a simple string into a tsvector.</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;Try not to become a man of success, but rather try to become a man of value&#39;</span><span class="p">);</span>

<span class="n">query</span> <span class="n">will</span> <span class="k">return</span> <span class="n">the</span> <span class="n">following</span> <span class="k">result</span><span class="p">:</span>

                             <span class="n">to_tsvector</span>
<span class="c1">----------------------------------------------------------------------</span>
<span class="s1">&#39;becom&#39;</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">13</span> <span class="s1">&#39;man&#39;</span><span class="p">:</span><span class="mi">6</span><span class="p">,</span><span class="mi">15</span> <span class="s1">&#39;rather&#39;</span><span class="p">:</span><span class="mi">10</span> <span class="s1">&#39;success&#39;</span><span class="p">:</span><span class="mi">8</span> <span class="s1">&#39;tri&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span> <span class="s1">&#39;valu&#39;</span><span class="p">:</span><span class="mi">17</span>
<span class="p">(</span><span class="mi">1</span> <span class="k">row</span><span class="p">)</span></code></pre></div>

<p>Something weird just happened. First there are fewer words than in the original sentence, some of the words are different (<code>try</code> became <code>tri</code>) and they are all followed by numbers. Why?</p>

<p>A <code>tsvector</code> value is a sorted list of distinct lexemes which are words that have been normalized to make different variants of the same word look alike.
For example, normalization almost always includes folding upper-case letters to lower-case and often involves removal of suffixes (such as &#39;s&#39;, &#39;es&#39; or &#39;ing&#39; in English). This allows searches to find variant forms of the same word without tediously entering all the possible variants.</p>

<p>The numbers represent the location of the lexeme in the original string. For example, &quot;man&quot; is present at position 6 and 15. Try counting the words and see for yourself.</p>

<p>By default, Postgres uses <code>&#39;english&#39;</code> as text search configuration for the function <code>to_tsvector</code> and it will also ignore english stopwords. 
That explains why the <code>tsvector</code> results have fewer elements than the ones in our sentence. We see later a bit more about languages and text search configuration.</p>

<h3>Querying</h3>

<p>We have seen how to build a document, but the goal here is to find the document. For running a query against a <code>tsvector</code> we can use the <code>@@</code> operator which is documented <a href="http://www.postgresql.org/docs/9.3/static/functions-textsearch.html#FUNCTIONS-TEXTSEARCH">here</a>. Let&#39;s see some examples on how to query our document.</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="o">&gt;</span> <span class="k">select</span> <span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;If you can dream it, you can do it&#39;</span><span class="p">)</span> <span class="o">@@</span> <span class="s1">&#39;dream&#39;</span><span class="p">;</span>
 <span class="o">?</span><span class="k">column</span><span class="o">?</span>
<span class="c1">----------</span>
 <span class="n">t</span>
<span class="p">(</span><span class="mi">1</span> <span class="k">row</span><span class="p">)</span>

<span class="o">&gt;</span> <span class="k">select</span> <span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;It&#39;&#39;s kind of fun to do the impossible&#39;</span><span class="p">)</span> <span class="o">@@</span> <span class="s1">&#39;impossible&#39;</span><span class="p">;</span>

 <span class="o">?</span><span class="k">column</span><span class="o">?</span>
<span class="c1">----------</span>
 <span class="n">f</span>
<span class="p">(</span><span class="mi">1</span> <span class="k">row</span><span class="p">)</span></code></pre></div>

<p>The second query returns false because we need to build a <code>tsquery</code> which creates the same lexemes and, using the operator <code>@@</code>, casts the string into a tsquery. The following shows the difference between casting and using the function <code>to_tsquery()</code></p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="s1">&#39;impossible&#39;</span><span class="p">::</span><span class="n">tsquery</span><span class="p">,</span> <span class="n">to_tsquery</span><span class="p">(</span><span class="s1">&#39;impossible&#39;</span><span class="p">);</span>
   <span class="n">tsquery</span>    <span class="o">|</span> <span class="n">to_tsquery</span>
<span class="c1">--------------+------------</span>
 <span class="s1">&#39;impossible&#39;</span> <span class="o">|</span> <span class="s1">&#39;imposs&#39;</span>
<span class="p">(</span><span class="mi">1</span> <span class="k">row</span><span class="p">)</span></code></pre></div>

<p>But in the case of &#39;dream&#39; the stem is equal to the word.</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="s1">&#39;dream&#39;</span><span class="p">::</span><span class="n">tsquery</span><span class="p">,</span> <span class="n">to_tsquery</span><span class="p">(</span><span class="s1">&#39;dream&#39;</span><span class="p">);</span>
   <span class="n">tsquery</span>    <span class="o">|</span> <span class="n">to_tsquery</span>
<span class="c1">--------------+------------</span>
 <span class="s1">&#39;dream&#39;</span>      <span class="o">|</span> <span class="s1">&#39;dream&#39;</span>
<span class="p">(</span><span class="mi">1</span> <span class="k">row</span><span class="p">)</span></code></pre></div>

<p>From now on we will use <code>to_tsquery</code> for querying documents.</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;It&#39;&#39;s kind of fun to do the impossible&#39;</span><span class="p">)</span> <span class="o">@@</span> <span class="n">to_tsquery</span><span class="p">(</span><span class="s1">&#39;impossible&#39;</span><span class="p">);</span>

 <span class="o">?</span><span class="k">column</span><span class="o">?</span>
<span class="c1">----------</span>
 <span class="n">t</span>
<span class="p">(</span><span class="mi">1</span> <span class="k">row</span><span class="p">)</span></code></pre></div>

<p>A tsquery value stores lexemes that are to be searched for, and combines them honoring the Boolean operators &amp; (AND), | (OR), and ! (NOT). Parentheses can be used to enforce grouping of the operators</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;If the facts don&#39;</span><span class="n">t</span> <span class="n">fit</span> <span class="n">the</span> <span class="n">theory</span><span class="p">,</span> <span class="n">change</span> <span class="n">the</span> <span class="n">facts</span><span class="s1">&#39;) @@ to_tsquery(&#39;</span><span class="o">!</span> <span class="n">fact</span><span class="s1">&#39;);</span>

<span class="s1"> ?column?</span>
<span class="s1">----------</span>
<span class="s1"> f</span>
<span class="s1">(1 row)</span>

<span class="s1">&gt; SELECT to_tsvector(&#39;</span><span class="n">If</span> <span class="n">the</span> <span class="n">facts</span> <span class="n">don</span><span class="s1">&#39;&#39;</span><span class="n">t</span> <span class="n">fit</span> <span class="n">the</span> <span class="n">theory</span><span class="p">,</span> <span class="n">change</span> <span class="n">the</span> <span class="n">facts</span><span class="s1">&#39;) @@ to_tsquery(&#39;</span><span class="n">theory</span> <span class="o">&amp;</span> <span class="o">!</span><span class="n">fact</span><span class="s1">&#39;);</span>

<span class="s1"> ?column?</span>
<span class="s1">----------</span>
<span class="s1"> f</span>
<span class="s1">(1 row)</span>

<span class="s1">&gt; SELECT to_tsvector(&#39;</span><span class="n">If</span> <span class="n">the</span> <span class="n">facts</span> <span class="n">don</span><span class="s1">&#39;&#39;</span><span class="n">t</span> <span class="n">fit</span> <span class="n">the</span> <span class="n">theory</span><span class="p">,</span> <span class="n">change</span> <span class="n">the</span> <span class="n">facts</span><span class="p">.</span><span class="s1">&#39;) @@ to_tsquery(&#39;</span><span class="n">fiction</span> <span class="o">|</span> <span class="n">theory</span><span class="err">&#39;</span><span class="p">);</span>

 <span class="o">?</span><span class="k">column</span><span class="o">?</span>
<span class="c1">----------</span>
 <span class="n">t</span>
<span class="p">(</span><span class="mi">1</span> <span class="k">row</span><span class="p">)</span></code></pre></div>

<p>We can also use startwith query style when using <code>:*</code>.</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;If the facts don&#39;&#39;t fit the theory, change the facts.&#39;</span><span class="p">)</span> <span class="o">@@</span> <span class="n">to_tsquery</span><span class="p">(</span><span class="s1">&#39;theo:*&#39;</span><span class="p">);</span>

 <span class="o">?</span><span class="k">column</span><span class="o">?</span>
<span class="c1">----------</span>
 <span class="n">t</span>
<span class="p">(</span><span class="mi">1</span> <span class="k">row</span><span class="p">)</span></code></pre></div>

<p>Now that we know how to make a full-text search query, we can come back to our initial table schema and try to query our documents.</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="n">pid</span><span class="p">,</span> <span class="n">p_title</span>
<span class="k">FROM</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">post</span><span class="p">.</span><span class="n">id</span> <span class="k">as</span> <span class="n">pid</span><span class="p">,</span>
             <span class="n">post</span><span class="p">.</span><span class="n">title</span> <span class="k">as</span> <span class="n">p_title</span><span class="p">,</span>
             <span class="n">to_tsvector</span><span class="p">(</span><span class="n">post</span><span class="p">.</span><span class="n">title</span><span class="p">)</span> <span class="o">||</span> 
             <span class="n">to_tsvector</span><span class="p">(</span><span class="n">post</span><span class="p">.</span><span class="n">content</span><span class="p">)</span> <span class="o">||</span>
             <span class="n">to_tsvector</span><span class="p">(</span><span class="n">author</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="o">||</span>
             <span class="n">to_tsvector</span><span class="p">(</span><span class="n">coalesce</span><span class="p">(</span><span class="n">string_agg</span><span class="p">(</span><span class="n">tag</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)))</span> <span class="k">as</span> <span class="n">document</span>
      <span class="k">FROM</span> <span class="n">post</span>
      <span class="k">JOIN</span> <span class="n">author</span> <span class="k">ON</span> <span class="n">author</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">post</span><span class="p">.</span><span class="n">author_id</span>
      <span class="k">JOIN</span> <span class="n">posts_tags</span> <span class="k">ON</span> <span class="n">posts_tags</span><span class="p">.</span><span class="n">post_id</span> <span class="o">=</span> <span class="n">posts_tags</span><span class="p">.</span><span class="n">tag_id</span>
      <span class="k">JOIN</span> <span class="n">tag</span> <span class="k">ON</span> <span class="n">tag</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">posts_tags</span><span class="p">.</span><span class="n">tag_id</span>
      <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">post</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">author</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="n">p_search</span>
<span class="k">WHERE</span> <span class="n">p_search</span><span class="p">.</span><span class="n">document</span> <span class="o">@@</span> <span class="n">to_tsquery</span><span class="p">(</span><span class="s1">&#39;Endangered &amp; Species&#39;</span><span class="p">);</span>

 <span class="n">pid</span> <span class="o">|</span>      <span class="n">p_title</span>
<span class="c1">-----+--------------------</span>
   <span class="mi">1</span> <span class="o">|</span> <span class="n">Endangered</span> <span class="n">species</span>
<span class="p">(</span><span class="mi">1</span> <span class="k">row</span><span class="p">)</span></code></pre></div>

<p>This will find our document which contains <code>Endangered</code> and <code>Species</code> or lexemes close enough.</p>

<h3>Language support</h3>

<p>Postgres provides built-ins text search for many languages: Danish, Dutch, English, Finnish, French, German, Hungarian, Italian, Norwegian, Portuguese, Romanian, Russian, Spanish, Swedish, Turkish.</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;english&#39;</span><span class="p">,</span> <span class="s1">&#39;We are running&#39;</span><span class="p">);</span>
 <span class="n">to_tsvector</span>
<span class="c1">-------------</span>
 <span class="s1">&#39;run&#39;</span><span class="p">:</span><span class="mi">3</span>
<span class="p">(</span><span class="mi">1</span> <span class="k">row</span><span class="p">)</span>

<span class="k">SELECT</span> <span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;french&#39;</span><span class="p">,</span> <span class="s1">&#39;We are running&#39;</span><span class="p">);</span>
        <span class="n">to_tsvector</span>
<span class="c1">----------------------------</span>
 <span class="s1">&#39;are&#39;</span><span class="p">:</span><span class="mi">2</span> <span class="s1">&#39;running&#39;</span><span class="p">:</span><span class="mi">3</span> <span class="s1">&#39;we&#39;</span><span class="p">:</span><span class="mi">1</span>
<span class="p">(</span><span class="mi">1</span> <span class="k">row</span><span class="p">)</span></code></pre></div>

<p>A column name can be used to create the <code>tsvector</code> based on our starting model. Let&#39;s assume that <code>post</code> can be written in different languages and post contains a column <code>language</code>.</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">post</span> <span class="k">ADD</span> <span class="k">language</span> <span class="nb">text</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">DEFAULT</span><span class="p">(</span><span class="s1">&#39;english&#39;</span><span class="p">);</span></code></pre></div>

<p>We can now rebuild our document to use this language column.</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="n">to_tsvector</span><span class="p">(</span><span class="n">post</span><span class="p">.</span><span class="k">language</span><span class="p">::</span><span class="n">regconfig</span><span class="p">,</span> <span class="n">post</span><span class="p">.</span><span class="n">title</span><span class="p">)</span> <span class="o">||</span> 
       <span class="n">to_tsvector</span><span class="p">(</span><span class="n">post</span><span class="p">.</span><span class="k">language</span><span class="p">::</span><span class="n">regconfig</span><span class="p">,</span> <span class="n">post</span><span class="p">.</span><span class="n">content</span><span class="p">)</span> <span class="o">||</span>
       <span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;simple&#39;</span><span class="p">,</span> <span class="n">author</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="o">||</span>
       <span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;simple&#39;</span><span class="p">,</span> <span class="n">coalesce</span><span class="p">((</span><span class="n">string_agg</span><span class="p">(</span><span class="n">tag</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)),</span> <span class="s1">&#39;&#39;</span><span class="p">))</span> <span class="k">as</span> <span class="n">document</span>
<span class="k">FROM</span> <span class="n">post</span>
<span class="k">JOIN</span> <span class="n">author</span> <span class="k">ON</span> <span class="n">author</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">post</span><span class="p">.</span><span class="n">author_id</span>
<span class="k">JOIN</span> <span class="n">posts_tags</span> <span class="k">ON</span> <span class="n">posts_tags</span><span class="p">.</span><span class="n">post_id</span> <span class="o">=</span> <span class="n">posts_tags</span><span class="p">.</span><span class="n">tag_id</span>
<span class="k">JOIN</span> <span class="n">tag</span> <span class="k">ON</span> <span class="n">tag</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">posts_tags</span><span class="p">.</span><span class="n">tag_id</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">post</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">author</span><span class="p">.</span><span class="n">id</span><span class="p">;</span></code></pre></div>

<p>Without the explicit cast <code>::regconfig</code> the query will have generated an error:</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="n">ERROR</span><span class="p">:</span>  <span class="k">function</span> <span class="n">to_tsvector</span><span class="p">(</span><span class="nb">text</span><span class="p">,</span> <span class="nb">text</span><span class="p">)</span> <span class="n">does</span> <span class="k">not</span> <span class="n">exist</span></code></pre></div>

<p><code>regconfig</code> is the object identifier type which represents the text search configuration in Postgres: http://www.postgresql.org/docs/9.3/static/datatype-oid.html</p>

<p>Fow now the lexemes of our document will be built using the right language based on <code>post.language</code>.</p>

<p>We also used <code>simple</code> which is one of the built in search text configs that Postgres provides. <code>simple</code> doesn&#39;t ignore stopwords and doesn&#39;t try to find the <a href="http://en.wikipedia.org/wiki/Stemming">stem</a> of the word. With <code>simple</code> every group of characters separated by a space is a lexeme; the <code>simple</code> text search config is pratical for data like a person&#39;s name for which we may not want to find the <a href="http://en.wikipedia.org/wiki/Stemming">stem</a> of the word. </p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;simple&#39;</span><span class="p">,</span> <span class="s1">&#39;We are running&#39;</span><span class="p">);</span>
        <span class="n">to_tsvector</span>
<span class="c1">----------------------------</span>
 <span class="s1">&#39;are&#39;</span><span class="p">:</span><span class="mi">2</span> <span class="s1">&#39;running&#39;</span><span class="p">:</span><span class="mi">3</span> <span class="s1">&#39;we&#39;</span><span class="p">:</span><span class="mi">1</span>
<span class="p">(</span><span class="mi">1</span> <span class="k">row</span><span class="p">)</span></code></pre></div>

<h3>Accented Character</h3>

<p>When you build a search engine supporting many languages you will also hit the accent problem. In many languages, accents are very important and can change the meaning of the word. Postgres ships with an extension call <code>unaccent</code> which is useful to unaccentuate content.  </p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="n">EXTENSION</span> <span class="n">unaccent</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="n">unaccent</span><span class="p">(</span><span class="s1">&#39;√®√©√™√´&#39;</span><span class="p">);</span>

 <span class="n">unaccent</span>
<span class="c1">----------</span>
 <span class="n">eeee</span>
<span class="p">(</span><span class="mi">1</span> <span class="k">row</span><span class="p">)</span></code></pre></div>

<p>Let&#39;s add some accented content to our <code>post</code> table.</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">post</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">content</span><span class="p">,</span> <span class="n">author_id</span><span class="p">,</span> <span class="k">language</span><span class="p">)</span> 
<span class="k">VALUES</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;il √©tait une fois&#39;</span><span class="p">,</span> <span class="s1">&#39;il √©tait une fois un h√¥tel ...&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span><span class="s1">&#39;french&#39;</span><span class="p">)</span></code></pre></div>

<p>If we want to ignore accents when we build our document, then we can simply do the following:</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="n">to_tsvector</span><span class="p">(</span><span class="n">post</span><span class="p">.</span><span class="k">language</span><span class="p">,</span> <span class="n">unaccent</span><span class="p">(</span><span class="n">post</span><span class="p">.</span><span class="n">title</span><span class="p">))</span> <span class="o">||</span> 
       <span class="n">to_tsvector</span><span class="p">(</span><span class="n">post</span><span class="p">.</span><span class="k">language</span><span class="p">,</span> <span class="n">unaccent</span><span class="p">(</span><span class="n">post</span><span class="p">.</span><span class="n">content</span><span class="p">))</span> <span class="o">||</span>
       <span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;simple&#39;</span><span class="p">,</span> <span class="n">unaccent</span><span class="p">(</span><span class="n">author</span><span class="p">.</span><span class="n">name</span><span class="p">))</span> <span class="o">||</span>
       <span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;simple&#39;</span><span class="p">,</span> <span class="n">unaccent</span><span class="p">(</span><span class="n">coalesce</span><span class="p">(</span><span class="n">string_agg</span><span class="p">(</span><span class="n">tag</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">))))</span>
<span class="k">FROM</span> <span class="n">post</span>
<span class="k">JOIN</span> <span class="n">author</span> <span class="k">ON</span> <span class="n">author</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">post</span><span class="p">.</span><span class="n">author_id</span>
<span class="k">JOIN</span> <span class="n">posts_tags</span> <span class="k">ON</span> <span class="n">posts_tags</span><span class="p">.</span><span class="n">post_id</span> <span class="o">=</span> <span class="n">posts_tags</span><span class="p">.</span><span class="n">tag_id</span>
<span class="k">JOIN</span> <span class="n">tag</span> <span class="k">ON</span> <span class="n">author</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">post</span><span class="p">.</span><span class="n">author_id</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">p</span><span class="p">.</span><span class="n">id</span></code></pre></div>

<p>That works, but it&#39;s a bit cumbersome with more room for mistakes. We can also build a new text search config with support for unaccented characters.</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="nb">TEXT</span> <span class="k">SEARCH</span> <span class="n">CONFIGURATION</span> <span class="n">fr</span> <span class="p">(</span> <span class="k">COPY</span> <span class="o">=</span> <span class="n">french</span> <span class="p">);</span>
<span class="k">ALTER</span> <span class="nb">TEXT</span> <span class="k">SEARCH</span> <span class="n">CONFIGURATION</span> <span class="n">fr</span> <span class="k">ALTER</span> <span class="n">MAPPING</span>
<span class="k">FOR</span> <span class="n">hword</span><span class="p">,</span> <span class="n">hword_part</span><span class="p">,</span> <span class="n">word</span> <span class="k">WITH</span> <span class="n">unaccent</span><span class="p">,</span> <span class="n">french_stem</span><span class="p">;</span></code></pre></div>

<p>When we are using this new text search config, we can see the lexemes </p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;french&#39;</span><span class="p">,</span> <span class="s1">&#39;il √©tait une fois&#39;</span><span class="p">);</span>
 <span class="n">to_tsvector</span>
<span class="c1">-------------</span>
 <span class="s1">&#39;fois&#39;</span><span class="p">:</span><span class="mi">4</span>
<span class="p">(</span><span class="mi">1</span> <span class="k">row</span><span class="p">)</span>

<span class="k">SELECT</span> <span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;fr&#39;</span><span class="p">,</span> <span class="s1">&#39;il √©tait une fois&#39;</span><span class="p">);</span>
    <span class="n">to_tsvector</span>
<span class="c1">--------------------</span>
 <span class="s1">&#39;etait&#39;</span><span class="p">:</span><span class="mi">2</span> <span class="s1">&#39;fois&#39;</span><span class="p">:</span><span class="mi">4</span>
<span class="p">(</span><span class="mi">1</span> <span class="k">row</span><span class="p">)</span></code></pre></div>

<p>This gives us the same result as applying <code>unaccent</code> first and building the <code>tsvector</code> from the result.</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;french&#39;</span><span class="p">,</span> <span class="n">unaccent</span><span class="p">(</span><span class="s1">&#39;il √©tait une fois&#39;</span><span class="p">));</span>
    <span class="n">to_tsvector</span>
<span class="c1">--------------------</span>
 <span class="s1">&#39;etait&#39;</span><span class="p">:</span><span class="mi">2</span> <span class="s1">&#39;fois&#39;</span><span class="p">:</span><span class="mi">4</span>
<span class="p">(</span><span class="mi">1</span> <span class="k">row</span><span class="p">)</span></code></pre></div>

<p>The number of lexemes is different because <code>il √©tait une</code> are stopwords in French. Is it an issue to keep these stop words in our document? I don&#39;t think so as <code>etait</code> is not really a stopword as it&#39;s misspelled.</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;fr&#39;</span><span class="p">,</span> <span class="s1">&#39;H√¥tel&#39;</span><span class="p">)</span> <span class="o">@@</span> <span class="n">to_tsquery</span><span class="p">(</span><span class="s1">&#39;hotels&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="k">result</span><span class="p">;</span>
 <span class="k">result</span>
<span class="c1">--------</span>
 <span class="n">t</span>
<span class="p">(</span><span class="mi">1</span> <span class="k">row</span><span class="p">)</span></code></pre></div>

<p>If we create an unaccented search config for each language that our <code>post</code> can be written in and we keep this value in <code>post.language</code> then we can keep our previous document query. </p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="n">to_tsvector</span><span class="p">(</span><span class="n">post</span><span class="p">.</span><span class="k">language</span><span class="p">,</span> <span class="n">post</span><span class="p">.</span><span class="n">title</span><span class="p">)</span> <span class="o">||</span> 
       <span class="n">to_tsvector</span><span class="p">(</span><span class="n">post</span><span class="p">.</span><span class="k">language</span><span class="p">,</span> <span class="n">post</span><span class="p">.</span><span class="n">content</span><span class="p">)</span> <span class="o">||</span>
       <span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;simple&#39;</span><span class="p">,</span> <span class="n">author</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="o">||</span>
       <span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;simple&#39;</span><span class="p">,</span> <span class="n">coalesce</span><span class="p">(</span><span class="n">string_agg</span><span class="p">(</span><span class="n">tag</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)))</span>
<span class="k">FROM</span> <span class="n">post</span>
<span class="k">JOIN</span> <span class="n">author</span> <span class="k">ON</span> <span class="n">author</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">post</span><span class="p">.</span><span class="n">author_id</span>
<span class="k">JOIN</span> <span class="n">posts_tags</span> <span class="k">ON</span> <span class="n">posts_tags</span><span class="p">.</span><span class="n">post_id</span> <span class="o">=</span> <span class="n">posts_tags</span><span class="p">.</span><span class="n">tag_id</span>
<span class="k">JOIN</span> <span class="n">tag</span> <span class="k">ON</span> <span class="n">author</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">post</span><span class="p">.</span><span class="n">author_id</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">p</span><span class="p">.</span><span class="n">id</span></code></pre></div>

<p>If you need to create unaccented text search config for each language supported by Postgres then you can use this <a href="https://gist.github.com/rach/9289959">gist</a></p>

<p>Our document will now likely increase in size because it can include unaccented stopwords but we query it without caring about accented characters. This can be useful e.g. for somebody with an english keyboard searching french content.</p>

<h3>Ranking</h3>

<p>When you build a search engine you want to be able to get search results ordered by relevance. The ranking of documents is based on many factors which are roughly explained in this documentation.</p>

<blockquote>
<p>Ranking attempts to measure how relevant documents are to a particular query, so that when there are many matches the most relevant ones can be shown first. PostgreSQL provides two predefined ranking functions, which take into account lexical, proximity, and structural information; that is, they consider how often the query terms appear in the document, how close together the terms are in the document, and how important is the part of the document where they occur.</p>

<p>-- <a href="http://www.postgresql.org/docs/9.3/static/textsearch-controls.html#TEXTSEARCH-RANKING">PostgreSQL documentation</a></p>
</blockquote>

<p>To order our results by relevance PostgreSQL provides a few functions but in our example we will be using only 2 of them: <code>ts_rank()</code> and <code>setweight()</code>.</p>

<p>The function <code>setweight</code> allows us to assign a weight value to a <code>tsvector</code>; the value can be <code>&#39;A&#39;, &#39;B&#39;, &#39;C&#39; or &#39;D&#39;</code></p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="n">pid</span><span class="p">,</span> <span class="n">p_title</span>
<span class="k">FROM</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">post</span><span class="p">.</span><span class="n">id</span> <span class="k">as</span> <span class="n">pid</span><span class="p">,</span>
             <span class="n">post</span><span class="p">.</span><span class="n">title</span> <span class="k">as</span> <span class="n">p_title</span><span class="p">,</span>
             <span class="n">setweight</span><span class="p">(</span><span class="n">to_tsvector</span><span class="p">(</span><span class="n">post</span><span class="p">.</span><span class="k">language</span><span class="p">::</span><span class="n">regconfig</span><span class="p">,</span> <span class="n">post</span><span class="p">.</span><span class="n">title</span><span class="p">),</span> <span class="s1">&#39;A&#39;</span><span class="p">)</span> <span class="o">||</span> 
             <span class="n">setweight</span><span class="p">(</span><span class="n">to_tsvector</span><span class="p">(</span><span class="n">post</span><span class="p">.</span><span class="k">language</span><span class="p">::</span><span class="n">regconfig</span><span class="p">,</span> <span class="n">post</span><span class="p">.</span><span class="n">content</span><span class="p">),</span> <span class="s1">&#39;B&#39;</span><span class="p">)</span> <span class="o">||</span>
             <span class="n">setweight</span><span class="p">(</span><span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;simple&#39;</span><span class="p">,</span> <span class="n">author</span><span class="p">.</span><span class="n">name</span><span class="p">),</span> <span class="s1">&#39;C&#39;</span><span class="p">)</span> <span class="o">||</span>
             <span class="n">setweight</span><span class="p">(</span><span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;simple&#39;</span><span class="p">,</span> <span class="n">coalesce</span><span class="p">(</span><span class="n">string_agg</span><span class="p">(</span><span class="n">tag</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">))),</span> <span class="s1">&#39;B&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">document</span>
      <span class="k">FROM</span> <span class="n">post</span>
      <span class="k">JOIN</span> <span class="n">author</span> <span class="k">ON</span> <span class="n">author</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">post</span><span class="p">.</span><span class="n">author_id</span>
      <span class="k">JOIN</span> <span class="n">posts_tags</span> <span class="k">ON</span> <span class="n">posts_tags</span><span class="p">.</span><span class="n">post_id</span> <span class="o">=</span> <span class="n">posts_tags</span><span class="p">.</span><span class="n">tag_id</span>
      <span class="k">JOIN</span> <span class="n">tag</span> <span class="k">ON</span> <span class="n">tag</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">posts_tags</span><span class="p">.</span><span class="n">tag_id</span>
      <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">post</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">author</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="n">p_search</span>
<span class="k">WHERE</span> <span class="n">p_search</span><span class="p">.</span><span class="n">document</span> <span class="o">@@</span> <span class="n">to_tsquery</span><span class="p">(</span><span class="s1">&#39;english&#39;</span><span class="p">,</span> <span class="s1">&#39;Endangered &amp; Species&#39;</span><span class="p">)</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">ts_rank</span><span class="p">(</span><span class="n">p_search</span><span class="p">.</span><span class="n">document</span><span class="p">,</span> <span class="n">to_tsquery</span><span class="p">(</span><span class="s1">&#39;english&#39;</span><span class="p">,</span> <span class="s1">&#39;Endangered &amp; Species&#39;</span><span class="p">))</span> <span class="k">DESC</span><span class="p">;</span></code></pre></div>

<p>In the query above, we have assigned different weights to the different fields of a document. <code>post.title</code> is more important than the <code>post.content</code> and as important as the <code>tag</code> associated. The least important is the <code>author.name</code>. </p>

<p>This means that if we were to search for the term &#39;Alice&#39; a document that contains that term in its title would be returned before a document that contains the term in its content and document that with an author of that name would be returned last.</p>

<p>Based on the weights assigned to parts of our document the <code>ts_rank()</code> returns a floating number which represents the relevancy of our document against the query.</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="n">ts_rank</span><span class="p">(</span><span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;This is an example of document&#39;</span><span class="p">),</span> 
               <span class="n">to_tsquery</span><span class="p">(</span><span class="s1">&#39;example | document&#39;</span><span class="p">))</span> <span class="k">as</span> <span class="n">relevancy</span><span class="p">;</span>
 <span class="n">relevancy</span>
<span class="c1">-----------</span>
 <span class="mi">0</span><span class="p">.</span><span class="mi">0607927</span>
<span class="p">(</span><span class="mi">1</span> <span class="k">row</span><span class="p">)</span>


<span class="k">SELECT</span> <span class="n">ts_rank</span><span class="p">(</span><span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;This is an example of document&#39;</span><span class="p">),</span> 
               <span class="n">to_tsquery</span><span class="p">(</span><span class="s1">&#39;example &#39;</span><span class="p">))</span> <span class="k">as</span> <span class="n">relevancy</span><span class="p">;</span>
 <span class="n">relevancy</span>
<span class="c1">-----------</span>
 <span class="mi">0</span><span class="p">.</span><span class="mi">0607927</span>
<span class="p">(</span><span class="mi">1</span> <span class="k">row</span><span class="p">)</span>


<span class="k">SELECT</span> <span class="n">ts_rank</span><span class="p">(</span><span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;This is an example of document&#39;</span><span class="p">),</span> 
               <span class="n">to_tsquery</span><span class="p">(</span><span class="s1">&#39;example | unkown&#39;</span><span class="p">))</span> <span class="k">as</span> <span class="n">relevancy</span><span class="p">;</span>
 <span class="n">relevancy</span>
<span class="c1">-----------</span>
 <span class="mi">0</span><span class="p">.</span><span class="mi">0303964</span>
<span class="p">(</span><span class="mi">1</span> <span class="k">row</span><span class="p">)</span>


<span class="k">SELECT</span> <span class="n">ts_rank</span><span class="p">(</span><span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;This is an example of document&#39;</span><span class="p">),</span>
               <span class="n">to_tsquery</span><span class="p">(</span><span class="s1">&#39;example &amp; document&#39;</span><span class="p">))</span> <span class="k">as</span> <span class="n">relevancy</span><span class="p">;</span>
 <span class="n">relevancy</span>
<span class="c1">-----------</span>
 <span class="mi">0</span><span class="p">.</span><span class="mi">0985009</span>
<span class="p">(</span><span class="mi">1</span> <span class="k">row</span><span class="p">)</span>


<span class="k">SELECT</span> <span class="n">ts_rank</span><span class="p">(</span><span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;This is an example of document&#39;</span><span class="p">),</span> 
               <span class="n">to_tsquery</span><span class="p">(</span><span class="s1">&#39;example &amp; unknown&#39;</span><span class="p">))</span> <span class="k">as</span> <span class="n">relevancy</span><span class="p">;</span>
 <span class="n">relevancy</span>
<span class="c1">-----------</span>
 <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">20</span>
<span class="p">(</span><span class="mi">1</span> <span class="k">row</span><span class="p">)</span></code></pre></div>

<p>However, the concept of relevancy is vague and very application-specific. Different applications might require additional information for ranking, e.g., document modification time. The built-in ranking functions such as <code>ts_rank</code> are only examples. You can write your own ranking functions and/or combine their results with additional factors to fit your specific needs. </p>

<p>To illustrate the paragraph above, if we wanted to promote newer posts against older ones we could divide the ts_rank value by the age of the document +1 (to avoid dividing by zero).</p>

<h3>Optimization and Indexing</h3>

<p>Optimizing the search on one table is straight forward. PostgreSQL supports function based indexes so you can simply create a GIN index around the <code>tsvector()</code> function.</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">idx_fts_post</span> <span class="k">ON</span> <span class="n">post</span> 
<span class="k">USING</span> <span class="n">gin</span><span class="p">((</span><span class="n">setweight</span><span class="p">(</span><span class="n">to_tsvector</span><span class="p">(</span><span class="k">language</span><span class="p">::</span><span class="n">regconfig</span><span class="p">,</span> <span class="n">title</span><span class="p">),</span><span class="s1">&#39;A&#39;</span><span class="p">)</span> <span class="o">||</span> 
       <span class="n">setweight</span><span class="p">(</span><span class="n">to_tsvector</span><span class="p">(</span><span class="k">language</span><span class="p">::</span><span class="n">regconfig</span><span class="p">,</span> <span class="n">content</span><span class="p">),</span> <span class="s1">&#39;B&#39;</span><span class="p">)));</span>

<span class="c1">-- If this throws an IMMUTABLE error then you can use this workaround</span>

<span class="k">CREATE</span> <span class="k">OR</span> <span class="k">REPLACE</span> <span class="k">FUNCTION</span> <span class="n">gin_fts_fct</span><span class="p">(</span><span class="n">title</span> <span class="nb">text</span><span class="p">,</span> <span class="n">content</span> <span class="nb">text</span><span class="p">,</span> <span class="k">language</span> <span class="nb">text</span><span class="p">)</span> 
  <span class="k">RETURNS</span> <span class="n">tsvector</span>
<span class="k">AS</span>
<span class="err">$</span><span class="n">BODY</span><span class="err">$</span>
    <span class="k">SELECT</span> <span class="n">setweight</span><span class="p">(</span><span class="n">to_tsvector</span><span class="p">(</span><span class="err">$</span><span class="mi">3</span><span class="p">::</span><span class="n">regconfig</span><span class="p">,</span> <span class="err">$</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;A&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="n">setweight</span><span class="p">(</span><span class="n">to_tsvector</span><span class="p">(</span><span class="err">$</span><span class="mi">3</span><span class="p">::</span><span class="n">regconfig</span><span class="p">,</span> <span class="err">$</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;B&#39;</span><span class="p">);</span>
<span class="err">$</span><span class="n">BODY</span><span class="err">$</span>
<span class="k">LANGUAGE</span> <span class="k">sql</span>
<span class="k">IMMUTABLE</span><span class="p">;</span>

<span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">idx_fts_post</span> <span class="k">ON</span> <span class="n">post</span>  <span class="k">USING</span> <span class="n">gin</span><span class="p">(</span><span class="n">gin_fts_fct</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">content</span><span class="p">,</span> <span class="k">language</span><span class="p">));</span></code></pre></div>

<p>GIN or GiST indexes? These two indexes could be subject of a blog post themselves. GiST can produce false matches which then requires a extra table row lookup to confirm the match. On the other hand, GIN is faster to query but bigger and slower to build.</p>

<blockquote>
<p>As a rule of thumb, GIN indexes are best for static data because lookups are faster. For dynamic data, GiST indexes are faster to update. Specifically, GiST indexes are very good for dynamic data and fast if the number of unique words (lexemes) is under 100,000 while GIN indexes will handle 100,000+ lexemes better but are slower to update.</p>

<p>-- <a href="http://www.postgresql.org/docs/9.1/static/textsearch-indexes.html">Postgres doc : Chap 12 Full Text Search</a></p>
</blockquote>

<p>For our example, we will be using GIN but the choice can be argued and you need to take your own decision based on your data.</p>

<p>We have a problem in our schema example; the document is spread across multiple tables with different weights. For a better performance it&#39;s necessary to denormalize the data via triggers or materialized view. </p>

<p>You don&#39;t always need to denormalise and in some cases you can add a function based index as we did above. Alternatively you can easily denormalise data from the same table via the postgres trigger function <code>tsvector_update_trigger(...)</code> or <code>tsvector_update_trigger_column(...)</code>. See the <a href="http://www.postgresql.org/docs/9.3/static/textsearch-features.html#TEXTSEARCH-UPDATE-TRIGGERS">Postgres doc</a> for more detailed information.</p>

<p>If it&#39;s acceptable of having some delay before a document can be found via search query then this may be a good use case for using a Materialized View so we can build an extra index on it.</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="n">MATERIALIZED</span> <span class="k">VIEW</span> <span class="n">search_index</span> <span class="k">AS</span> 
<span class="k">SELECT</span> <span class="n">post</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
       <span class="n">post</span><span class="p">.</span><span class="n">title</span><span class="p">,</span>
       <span class="n">setweight</span><span class="p">(</span><span class="n">to_tsvector</span><span class="p">(</span><span class="n">post</span><span class="p">.</span><span class="k">language</span><span class="p">::</span><span class="n">regconfig</span><span class="p">,</span> <span class="n">post</span><span class="p">.</span><span class="n">title</span><span class="p">),</span> <span class="s1">&#39;A&#39;</span><span class="p">)</span> <span class="o">||</span> 
       <span class="n">setweight</span><span class="p">(</span><span class="n">to_tsvector</span><span class="p">(</span><span class="n">post</span><span class="p">.</span><span class="k">language</span><span class="p">::</span><span class="n">regconfig</span><span class="p">,</span> <span class="n">post</span><span class="p">.</span><span class="n">content</span><span class="p">),</span> <span class="s1">&#39;B&#39;</span><span class="p">)</span> <span class="o">||</span>
       <span class="n">setweight</span><span class="p">(</span><span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;simple&#39;</span><span class="p">,</span> <span class="n">author</span><span class="p">.</span><span class="n">name</span><span class="p">),</span> <span class="s1">&#39;C&#39;</span><span class="p">)</span> <span class="o">||</span>
       <span class="n">setweight</span><span class="p">(</span><span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;simple&#39;</span><span class="p">,</span> <span class="n">coalesce</span><span class="p">(</span><span class="n">string_agg</span><span class="p">(</span><span class="n">tag</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">))),</span> <span class="s1">&#39;A&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">document</span>
<span class="k">FROM</span> <span class="n">post</span>
<span class="k">JOIN</span> <span class="n">author</span> <span class="k">ON</span> <span class="n">author</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">post</span><span class="p">.</span><span class="n">author_id</span>
<span class="k">JOIN</span> <span class="n">posts_tags</span> <span class="k">ON</span> <span class="n">posts_tags</span><span class="p">.</span><span class="n">post_id</span> <span class="o">=</span> <span class="n">posts_tags</span><span class="p">.</span><span class="n">tag_id</span>
<span class="k">JOIN</span> <span class="n">tag</span> <span class="k">ON</span> <span class="n">tag</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">posts_tags</span><span class="p">.</span><span class="n">tag_id</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">post</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">author</span><span class="p">.</span><span class="n">id</span></code></pre></div>

<p>Then reindexing the search engine will be as simple as periodically running   <code>REFRESH MATERIALIZED VIEW search_index;</code>.</p>

<p>We can now add an index on the materialized view.</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">idx_fts_search</span> <span class="k">ON</span> <span class="n">search_index</span> <span class="k">USING</span> <span class="n">gin</span><span class="p">(</span><span class="n">document</span><span class="p">);</span></code></pre></div>

<p>And querying will become much simpler too.</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="n">id</span> <span class="k">as</span> <span class="n">post_id</span><span class="p">,</span> <span class="n">title</span>
<span class="k">FROM</span> <span class="n">search_index</span>
<span class="k">WHERE</span> <span class="n">document</span> <span class="o">@@</span> <span class="n">to_tsquery</span><span class="p">(</span><span class="s1">&#39;english&#39;</span><span class="p">,</span> <span class="s1">&#39;Endangered &amp; Species&#39;</span><span class="p">)</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">ts_rank</span><span class="p">(</span><span class="n">p_search</span><span class="p">.</span><span class="n">document</span><span class="p">,</span> <span class="n">to_tsquery</span><span class="p">(</span><span class="s1">&#39;english&#39;</span><span class="p">,</span> <span class="s1">&#39;Endangered &amp; Species&#39;</span><span class="p">))</span> <span class="k">DESC</span><span class="p">;</span></code></pre></div>

<p>If you cannot afford delay then you may have to investigate the alternative method using triggers.</p>

<p>There is not one way to build your document store; it will depend on what comprises your document: single table, multiple table, multiple languages, amount of data ...</p>

<p><a href="http://thoughtbot.com/">Thoughtbot.com</a> published a good article on <a href="http://robots.thoughtbot.com/implementing-multi-table-full-text-search-with-postgres">&quot;Implementing Multi-Table Full Text Search with Postgres in Rails&quot;</a> which I advise reading.</p>

<h3>Mispelling</h3>

<p>PostgreSQL comes with a very useful extenstion called <code>pg_trgm</code>. See <a href="http://www.postgresql.org/docs/9.3/static/pgtrgm.html">pg_trgm doc</a>.</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="n">EXTENSION</span> <span class="n">pg_trgm</span><span class="p">;</span></code></pre></div>

<p>This provides support for trigram which is a <a href="http://en.wikipedia.org/wiki/N-gram">N-gram with</a> <code>N == 3</code>. N-grams are useful because they allow finding strings with similar characters and, in essence, that&#39;s what a misspelling is - a word that is similar but not quite right.</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="n">similarity</span><span class="p">(</span><span class="s1">&#39;Something&#39;</span><span class="p">,</span> <span class="s1">&#39;something&#39;</span><span class="p">);</span>
 <span class="n">similarity</span>
<span class="c1">------------</span>
     <span class="mi">1</span>
<span class="p">(</span><span class="mi">1</span> <span class="k">row</span><span class="p">)</span>

<span class="k">SELECT</span> <span class="n">similarity</span><span class="p">(</span><span class="s1">&#39;Something&#39;</span><span class="p">,</span> <span class="s1">&#39;samething&#39;</span><span class="p">);</span>
 <span class="n">similarity</span>
<span class="c1">------------</span>
  <span class="mi">0</span><span class="p">.</span><span class="mi">538462</span>
<span class="p">(</span><span class="mi">1</span> <span class="k">row</span><span class="p">)</span>

<span class="k">SELECT</span> <span class="n">similarity</span><span class="p">(</span><span class="s1">&#39;Something&#39;</span><span class="p">,</span> <span class="s1">&#39;unrelated&#39;</span><span class="p">);</span>
 <span class="n">similarity</span>
<span class="c1">------------</span>
     <span class="mi">0</span>
<span class="p">(</span><span class="mi">1</span> <span class="k">row</span><span class="p">)</span>

<span class="k">SELECT</span> <span class="n">similarity</span><span class="p">(</span><span class="s1">&#39;Something&#39;</span><span class="p">,</span> <span class="s1">&#39;everything&#39;</span><span class="p">);</span>
 <span class="n">similarity</span>                                          
<span class="c1">------------</span>
   <span class="mi">0</span><span class="p">.</span><span class="mi">235294</span>
<span class="p">(</span><span class="mi">1</span> <span class="k">row</span><span class="p">)</span>

<span class="k">SELECT</span> <span class="n">similarity</span><span class="p">(</span><span class="s1">&#39;Something&#39;</span><span class="p">,</span> <span class="s1">&#39;omething&#39;</span><span class="p">);</span>
 <span class="n">similarity</span>
<span class="c1">------------</span>
   <span class="mi">0</span><span class="p">.</span><span class="mi">583333</span>
<span class="p">(</span><span class="mi">1</span> <span class="k">row</span><span class="p">)</span></code></pre></div>

<p>With the examples above you can see that similarity returns a float to represent the similarity between two strings. To detect misspelling is then a matter of collecting the lexemes used by our documents and comparing the similarities with our search input. I found that 0.5 is a good number to test the similarity of misspelling. First we need to create this list of unique lexemes used by our documents.</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="n">MATERIALIZED</span> <span class="k">VIEW</span> <span class="n">unique_lexeme</span> <span class="k">AS</span>
<span class="k">SELECT</span> <span class="n">word</span> <span class="k">FROM</span> <span class="n">ts_stat</span><span class="p">(</span>
<span class="s1">&#39;SELECT to_tsvector(&#39;</span><span class="k">simple</span><span class="s1">&#39;, post.title) || </span>
<span class="s1">    to_tsvector(&#39;</span><span class="k">simple</span><span class="s1">&#39;, post.content) ||</span>
<span class="s1">    to_tsvector(&#39;</span><span class="k">simple</span><span class="s1">&#39;, author.name) ||</span>
<span class="s1">    to_tsvector(&#39;</span><span class="k">simple</span><span class="s1">&#39;, coalesce(string_agg(tag.name, &#39;</span> <span class="s1">&#39;)))</span>
<span class="s1">FROM post</span>
<span class="s1">JOIN author ON author.id = post.author_id</span>
<span class="s1">JOIN posts_tags ON posts_tags.post_id = posts_tags.tag_id</span>
<span class="s1">JOIN tag ON tag.id = posts_tags.tag_id</span>
<span class="s1">GROUP BY post.id, author.id&#39;</span><span class="p">);</span></code></pre></div>

<p>The query above builds a view with one column called <code>word</code> from all the unique lexemes of our documents. We used <code>simple</code> because our content can be in multiple languages. Once we create this materialized view we need to add an index to make the similarity query faster.</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">words_idx</span> <span class="k">ON</span> <span class="n">search_words</span> <span class="k">USING</span> <span class="n">gin</span><span class="p">(</span><span class="n">word</span> <span class="n">gin_trgm_ops</span><span class="p">);</span></code></pre></div>

<p>Luckily unique lexemes used in a search engine is not something that will change rapidly, so probably we won&#39;t have to refresh the materialized view too often via:  </p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="n">REFRESH</span> <span class="n">MATERIALIZED</span> <span class="k">VIEW</span> <span class="n">unique_lexeme</span><span class="p">;</span></code></pre></div>

<p>Once we have built this table finding the closest match is very simple.</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="n">word</span> 
<span class="k">WHERE</span> <span class="n">similarity</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="s1">&#39;samething&#39;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span> 
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">word</span> <span class="o">&lt;-&gt;</span> <span class="s1">&#39;samething&#39;</span>
<span class="k">LIMIT</span> <span class="mi">1</span><span class="p">;</span></code></pre></div>

<p>This query returns a lexeme which is similar enough (<code>&gt;0.5</code>) to the search input <code>samething</code> ordered by the closest first. The operator <code>&lt;-&gt;</code> returns the &quot;distance&quot; between the arguments, that is one minus the <code>similarity()</code> value. </p>

<p>When you decide to handle misspelling in your search you may want to not look for misspellings on every query. Instead, you could query for misspellings only when the search returns no results and use the results of that query to provide some suggestions to your user. It is also possible that your data may contain misspellings if it comes from some source of informal communication such as a social network in which case you may obtain good results by appending the similar lexeme to your <code>tsquery</code>.</p>

<p><a href="http://bartlettpublishing.com/site/bartpub/blog/3/entry/350">&quot;Super Fuzzy Searching on PostgreSQL&quot;</a> is a good reference article about the use of trigrams for using misspellings and search with Postgres. </p>

<p>In my use case the unique lexemes table has never been bigger than 2000 rows but from my understanding if you have more 1M unique lexemes used across your document then you may be meet performance issues with this technique.</p>

<h3>About MySQL and RDS</h3>

<h4>Does it work on Postgres RDS?</h4>

<p>All the examples illustrated work on RDS. From what I&#39;m aware the only restrictions on search features imposed by RDS are those that require access to the file system such as custom dictionaries, ispell, synonyms and thesaurus. See <a href="https://forums.aws.amazon.com/message.jspa?messageID=527000#527000">the related issue on the aws forum</a>.</p>

<h4>I&#39;m using MYSQL should I use the builtin full-text search?</h4>

<p>I wouldn&#39;t. Without starting a flame war, MySQL full-text search features are very limited. By default, there is no support for stemming nor any language support. I came accross a stemming function which can be installed, but MYSQL doesn&#39;t support function based indexes.</p>

<p>Then what can you do? Based on what we have discussed above if Postgres fulfills your use case then think about moving to Postgres. This can easily be done via tools like <a href="https://github.com/philipsoutham/py-mysql2pgsql/">py-mysql2pgsql</a>. Or you can investigate more advanced solutions like SOLR and Elasticsearch. </p>

<h3>Want to work on challenging projects using Postgres?</h3>

<p>If you are interested in working with Postgres on some interesting projects, come join me at <a href="http://bit.ly/24bUVmn">Opendoor</a>. We heavily use PostgreSQL for Data Processing, Web Development, Data Warehousing, ETLs, Data Science, and Geo Analysis. We are always looking for passionate Engineers and Data Scientists to join our team. Please reach out to our recruiter, <a href="mailto:ryan.jordan@opendoor.com">Ryan</a> or apply via our <a href="http://bit.ly/25nigE9">job page</a></p>

<h3>Conclusion</h3>

<p>We have seen how to build a decent multi-language search engine based on a non-trivial document. This article is only an overview, but it should give you enough background and examples to get you started with your own. I may have made some mistakes in this article and I would appreciate if you report them to <a href="mailto:blog@rachbelaid.com">blog@rachbelaid.com</a></p>

<p>The full-text search feature included in Postgres is awesome and quite fast (enough). It will allow your application to grow without depending on another tool. Is Postgres Search the silver bullet? Probably not if your core business needs revolve around search. </p>

<p>Some features are missing but in a lot of use cases you won&#39;t need them. It goes without saying that it&#39;s critical that you analyze and understand your needs to know which road to take.</p>

<p>Personally I hope to see the full-text search continuing to improve in Postgres and maybe a few of these features being included:</p>

<ul>
<li>Additional built-in language support. eg: Chinese, Japanese...</li>
<li>Foreign data wrapper around Lucene. Lucene is still the most advanced tool for full-text search and it will have a lot of benefits to see integration with Postgres.</li>
<li>More boost or scoring feature for the ranking of results would be first-rate. Elasticsearch and SOLR offer advanced solutions already.</li>
<li>A way to do fuzzy <code>tsquery</code> without having to use trigram would be nice. Elasticsearch offers a simple way to do fuzzy search queries.</li>
<li>Being able to create and edit dynamically features such as dictionary content, synonyms, thesaurus via SQL this removing the need to add files to the filesystem</li>
</ul>

<p>Postgres is not as advanced as ElasticSearch and SOLR, but these two are dedicated full-text search tools whereas full-text search is only a feature of PostgreSQL and a pretty good one.</p>

    </section>
</article>
<footer id="post-meta" class="clearfix">
    <a href="http://bit.ly/rachbelaid">
        <img class="avatar" src="/assets/images/avatar.png">
        <div>
            <span class="dark">Rachid Belaid</span>
            <span>Blogging about programming,<br/> computer sciences, databases and others stuffs</span>
        </div>
    </a>

    <section id="sharing">
        
  
  <a class="twitter" href="https://twitter.com/intent/tweet?text=http://bit.ly/1TQFnVu - Postgres full-text search is Good Enough! by @rachbelaid"><span class="icon-twitter"></span></a>
  <a class="facebook" href="#" onclick="
      window.open(
        'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
        'facebook-share-dialog',
        'width=626,height=436');
      return false;"><span class="icon-facebook"></span>
  </a>


    </section>
</footer>

<!-- Archive post list -->

    <ul id="post-list" class="archive readmore">
        <h3>Read more</h3>
        
           <li>
            <a href='/introducing-pome'><aside class="dates">March 5 2023</aside></a>
            <a href='/introducing-pome'>Introducing Catalog <h2> Catalog aggregates 100+ furniture websites to make finding the ideal furniture for you easier..</h2></a>
        </li>

    
        <li>
            <a href='/introducing-pome'><aside class="dates">Dec 31 2015</aside></a>
            <a href='/introducing-pome'>Introducing Pome <h2>Pome is a PostgreSQL Metrics Dashboard to keep track of the health of your db.</h2></a>
        </li>
    
        <li>
            <a href='/introducing-suma'><aside class="dates">Dec 30 2015</aside></a>
            <a href='/introducing-suma'>Introducing Suma <h2>Suma is microservice to manage, control, preview links to external urls within your project.</h2></a>
        </li>
    
        <li>
            <a href='/introduction-to-postgres-physical-storage'><aside class="dates">Nov 09 2015</aside></a>
            <a href='/introduction-to-postgres-physical-storage'>Introduction to PostgreSQL physical storage <h2>Let's dive in how PostgreSQL store your data. This post try make the subject more easy to understand.</h2></a>
        </li>
    
        <li>
            <a href='/embedding-assets-in-go-project'><aside class="dates">Sep 07 2015</aside></a>
            <a href='/embedding-assets-in-go-project'>Embedding static assets in a Go project <h2>If you want to ship a Go webapp as a binary, this post shows how to embed static assets (images, html, ...)</h2></a>
        </li>
    
        <li>
            <a href='/recursive-regular-experession'><aside class="dates">Aug 20 2015</aside></a>
            <a href='/recursive-regular-experession'>Recursive Regular Expression <h2>It's not really well known that regex support recursive pattern, this post introduces this feature.</h2></a>
        </li>
    
        <li>
            <a href='/capturing-screenshots-of-website-with-python'><aside class="dates">Aug 19 2015</aside></a>
            <a href='/capturing-screenshots-of-website-with-python'>Capturing screenshots of website with Python <h2>There are solutions depending on PyQt, this post describes an easier one depending of PhantomJS.</h2></a>
        </li>
    
        <li>
            <a href='/prefetch-id-with-sqlalchemy-and-postgres'><aside class="dates">Aug 18 2015</aside></a>
            <a href='/prefetch-id-with-sqlalchemy-and-postgres'>Prefetch ID with SQLAlchemy and PosgreSQL <h2>If you need to know the value of the row id before INSERT, this post shows you how.</h2></a>
        </li>
    
        <li>
            <a href='/handling-race-condition-insert-with-sqlalchemy'><aside class="dates">Aug 17 2015</aside></a>
            <a href='/handling-race-condition-insert-with-sqlalchemy'>Handling concurrent INSERT with SQLAlchemy <h2>If you've some unique constraints on a table then you may hit some race condition problem in some cases.</h2></a>
        </li>
    
        <li>
            <a href='/postgres-full-text-search-is-good-enough'><aside class="dates">Jul 13 2015</aside></a>
            <a href='/postgres-full-text-search-is-good-enough'>Postgres full-text search is Good Enough! <h2>Postgres full-text search is Good Enough!</h2></a>
        </li>
    
        <li>
            <a href='/virtualenvwrapper-plugins-for-gems-and-npms'><aside class="dates">Jul 10 2015</aside></a>
            <a href='/virtualenvwrapper-plugins-for-gems-and-npms'>Virtualenvwrapper plugins for gems and npms <h2>Plugins to make it easy and transparent to keep gems and npms inside your virtualenv</h2></a>
        </li>
    
        <li>
            <a href='/keep-your-gems-and-npms-inside-your-virtualenv'><aside class="dates">Jul 09</aside></a>
            <a href='/keep-your-gems-and-npms-inside-your-virtualenv'>Keep your gems and npms inside your virtualenv <h2>Nobody want having their gems or npms wondering around. Keep them tidy inside your virtualenv.</h2></a>
        </li>
    
        <li>
            <a href='/handling-go-workspace-with-direnv'><aside class="dates">Jun 28 2015</aside></a>
            <a href='/handling-go-workspace-with-direnv'>Handling Go workspace with direnv <h2>Bringing some sanity into your go project workspaces</h2></a>
        </li>
        
    </ul>





  </section>

  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
  <script src="/assets/js/main.js"></script>
  <script src="/assets/js/highlight.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-34383847-2', 'auto');
    ga('send', 'pageview');
  </script>
</body>
</html>



